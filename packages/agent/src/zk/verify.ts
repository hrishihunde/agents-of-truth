/**
 * @fileoverview ZK Proof Verification with SnarkJS
 * 
 * This module verifies Groth16 zk-SNARK proofs generated by prove.ts.
 * Verification confirms that:
 * 1. The proof is cryptographically valid
 * 2. The public signals match the claimed values
 */

// @ts-expect-error - snarkjs has no TypeScript declarations
import * as snarkjs from 'snarkjs';
import { readFile } from 'fs/promises';
import { existsSync } from 'fs';
import { dirname, join } from 'path';
import { fileURLToPath } from 'url';
import type { ZKProof, VerifyResult } from '../types.js';

// ================================
// Configuration
// ================================

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const VKEY_PATH = process.env.ZK_VERIFICATION_KEY || join(__dirname, 'verification_key.json');

// Cache the verification key
let cachedVKey: object | null = null;

// ================================
// Verification
// ================================

/**
 * Verify a zk proof of policy compliance
 * 
 * @param zkProof - The proof to verify
 * @returns Verification result
 * 
 * @example
 * ```typescript
 * const result = await verifyProof(proof);
 * 
 * if (result.valid) {
 *   console.log('Proof is valid!');
 * } else {
 *   console.log('Invalid proof:', result.error);
 * }
 * ```
 */
export async function verifyProof(zkProof: ZKProof): Promise<VerifyResult> {
    console.log('[ZK] Verifying proof...');

    // Check if verification key exists
    if (!existsSync(VKEY_PATH)) {
        console.warn('[ZK] Verification key not found at:', VKEY_PATH);
        console.warn('[ZK] Run "pnpm run zk:setup" to generate circuit files');

        // Return mock verification for development
        return mockVerify(zkProof);
    }

    try {
        // Load verification key (with caching)
        if (!cachedVKey) {
            console.log('[ZK] Loading verification key...');
            const vkeyJson = await readFile(VKEY_PATH, 'utf-8');
            cachedVKey = JSON.parse(vkeyJson);
            console.log('[ZK] Verification key loaded');
        }

        // Reconstruct the proof object for snarkjs
        const proof = {
            pi_a: zkProof.proof.pi_a,
            pi_b: zkProof.proof.pi_b,
            pi_c: zkProof.proof.pi_c,
            protocol: zkProof.proof.protocol,
            curve: zkProof.proof.curve,
        };

        console.log('[ZK] Running Groth16 verifier...');
        const startTime = Date.now();

        // Verify the proof
        const valid = await snarkjs.groth16.verify(
            cachedVKey,
            zkProof.publicSignals,
            proof
        );

        const duration = Date.now() - startTime;
        console.log(`[ZK] Verification complete in ${duration}ms: ${valid ? 'VALID' : 'INVALID'}`);

        return {
            valid,
            error: valid ? undefined : 'Proof verification failed',
        };

    } catch (error) {
        console.error('[ZK] Verification error:', error);

        return {
            valid: false,
            error: error instanceof Error ? error.message : 'Unknown verification error',
        };
    }
}

/**
 * Verify proof and extract public values
 * 
 * This verifies the proof and returns the decoded public signals.
 * 
 * @param zkProof - The proof to verify
 * @returns Verification result with decoded values
 */
export async function verifyProofWithValues(zkProof: ZKProof): Promise<{
    valid: boolean;
    commitment?: string;
    isValid?: boolean;
    maxSpend?: number;
    policyHash?: string;
    error?: string;
}> {
    const result = await verifyProof(zkProof);

    if (!result.valid) {
        return { valid: false, error: result.error };
    }

    // Decode public signals
    // Order: [commitment, isValid, maxSpend, policyHash]
    const [commitment, isValid, maxSpend, policyHash] = zkProof.publicSignals;

    return {
        valid: true,
        commitment,
        isValid: isValid === '1',
        maxSpend: Number(maxSpend) / 1e6, // Convert back from USDC decimals
        policyHash,
    };
}

/**
 * Check if a proof's public signals match expected values
 * 
 * This doesn't verify the cryptographic proof, just checks
 * that the claimed public values match expectations.
 * 
 * @param zkProof - The proof to check
 * @param expected - Expected public values
 * @returns Whether values match
 */
export function checkPublicSignals(
    zkProof: ZKProof,
    expected: {
        maxSpend?: number;
        policyHash?: string;
    }
): { matches: boolean; mismatches: string[] } {
    const mismatches: string[] = [];

    // [commitment, isValid, maxSpend, policyHash]
    const publicMaxSpend = Number(zkProof.publicSignals[2]) / 1e6;
    const publicPolicyHash = zkProof.publicSignals[3];

    if (expected.maxSpend !== undefined && publicMaxSpend !== expected.maxSpend) {
        mismatches.push(`maxSpend: expected ${expected.maxSpend}, got ${publicMaxSpend}`);
    }

    if (expected.policyHash !== undefined && publicPolicyHash !== expected.policyHash) {
        mismatches.push(`policyHash: expected ${expected.policyHash}, got ${publicPolicyHash}`);
    }

    return {
        matches: mismatches.length === 0,
        mismatches,
    };
}

// ================================
// Mock Verification (for development)
// ================================

/**
 * Mock verification when verification key isn't available
 * 
 * This is for development/testing only.
 * It performs basic structural checks but not cryptographic verification.
 */
function mockVerify(zkProof: ZKProof): VerifyResult {
    console.log('[ZK] Performing MOCK verification (not cryptographically secure)');

    // Check basic structure
    if (!zkProof.proof) {
        return { valid: false, error: 'Missing proof object' };
    }

    if (!zkProof.proof.pi_a || !zkProof.proof.pi_b || !zkProof.proof.pi_c) {
        return { valid: false, error: 'Invalid proof structure' };
    }

    if (!zkProof.publicSignals || zkProof.publicSignals.length === 0) {
        return { valid: false, error: 'Missing public signals' };
    }

    // Check isValid signal
    const isValid = zkProof.publicSignals[1];
    if (isValid !== '1') {
        return { valid: false, error: 'isValid signal is not 1' };
    }

    // Mock verification passes if structure is correct
    console.log('[ZK] Mock verification: PASSED');
    return { valid: true };
}

// ================================
// Utility Functions
// ================================

/**
 * Clear the cached verification key
 * Useful for testing or when key is updated
 */
export function clearVerificationKeyCache(): void {
    cachedVKey = null;
    console.log('[ZK] Verification key cache cleared');
}

/**
 * Export proof for external verification
 * 
 * Returns the proof in a format suitable for on-chain verification
 * or verification by other tools.
 */
export function exportProofForVerifier(zkProof: ZKProof): {
    a: [string, string];
    b: [[string, string], [string, string]];
    c: [string, string];
    input: string[];
} {
    return {
        a: [zkProof.proof.pi_a[0], zkProof.proof.pi_a[1]],
        b: [
            [zkProof.proof.pi_b[0][1], zkProof.proof.pi_b[0][0]], // Note: reversed for on-chain
            [zkProof.proof.pi_b[1][1], zkProof.proof.pi_b[1][0]],
        ],
        c: [zkProof.proof.pi_c[0], zkProof.proof.pi_c[1]],
        input: zkProof.publicSignals,
    };
}
